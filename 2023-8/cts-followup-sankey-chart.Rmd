---
title: "August 2023 CTS Viz of the Month"
author: "Kristen Savage"
date: "2023-08-09"
output:
  html_document:
    theme: cerulean
    highlight: tango
    keep_md: TRUE
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Packages used
```{r packages, eval=FALSE}
library(tidyverse)
library(networkD3)
```

### Description of inputs

* Data
    + A dataframe called "data_cts" where each unique combination of source and target is a row. This dataframe captures the total numbers of unique combinations between each CTS questionnaire and the respective follow-up. 
    + A Sankey chart requires a unique data structure; some of the same values will exist in both the source and target columns. For example, a participant can start at Q1 (source) and end at Q2 (target) and then start at Q2 (source) and end at Q3 (target). In this scenario, Q2 exists as a value in both the source and the target columns. 

* Variables
    + Source: A categorical variable that captures each possible starting point
    + Target: A categorical variable that captures each possible ending point
    + Value: the number of participants who moved from that specific source to that specific target.
    
* Generated Variables: these variables are generated by the code below
    + IDsource: The number associated with the category in the source column; these IDs are assigned for use in the Sankey chart.
    + IDtarget: The number associated with the category in the target column; these IDs are assigned for use in the Sankey chart.
    + group: the group assigned to that source-target pair. For this viz we assigned groups based based on the color we wanted to use for that specific pair. 

### Visualization code 
```{r viz, eval=FALSE}
# Input data
# load your data into a dataframe called data_cts

# Create a node data frame
# Run the code below to create a node data frame which lists each entity involved in the flow
nodes_cts <- data.frame(name=c(as.character(data_cts$source), as.character(data_cts$target)) %>% unique())

# With networkD3, connection must be provided using id, not using a name like in our existing dataframe.
# The code below will reformat the data to assign an ID.
data_cts$IDsource=match(data_cts$source, nodes_cts$name)-1 
data_cts$IDtarget=match(data_cts$target, nodes_cts$name)-1

# Assign Factors to Groups
# We need as many factors as we have rows/nodes.
# For this viz, we've assigned factors based on end-point type: 
#    + type_a = when participants move in linear fashion from questionnaire to questionnaire, i.e. source q1 
#               to target q2 or source q3 to target q4
#    + type_b = when participants skip a questionnaire and then come back, i.e. source q1 to target q4
#               or source q3 to target q6
#    + type_c = the outcome is died, meaning participants moved from a questionnaire to status of deceased
#    + type_d = the outcome is non-response, meaning participants completed a questionnaire and did not respond
#               again.

data_cts$group <- as.factor(c("type_a",
                                "type_b",
                                "type_b",
                                "type_b",
                                "type_b",
                                "type_a",
                                "type_b",
                                "type_b",
                                "type_b",
                                "type_a",
                                "type_b",
                                "type_b",
                                "type_a",
                                "type_b",
                                "type_a",
                                "type_c",
                                "type_c",
                                "type_c",
                                "type_c",
                                "type_c",
                                "type_c",
                                "type_a",
                                "type_d",
                                "type_d",
                                "type_d",
                                "type_d",
                                "type_d",
                                "type_d"))


# Assign Factors
nodes_cts$group <- as.factor(c("my_unique_group"))

# Prepare Color Scale
# We'll select the same number of colors that we have groups (five for this viz).
# The code below assigns to the colors to the groups - for example, type_a group will show up as color #2A7F62.
my_colornodes <- 'd3.scaleOrdinal() .domain(["type_a", "type_b", "type_c", "type_d", "my_unique_group"])
.range(["#2A7F62", "#538083", "#DFD9E2", "#C3ACCE", "#89909F"])'

# Make the Network
networkD3::sankeyNetwork(Links = data_cts, Nodes = nodes_cts,
                     Source = "IDsource", Target = "IDtarget",
                     Value = "value", NodeID = "name",
                     colourScale=my_colornodes, LinkGroup="group", NodeGroup="group",
                     fontSize = 14, fontFamily = "Times", 
                       nodeWidth = 15) 
```

##### Files in this folder:

- .png file: image of the viz of the month
- .Rmd file: the code used to create this document
- .html file: a downloadable version of this document